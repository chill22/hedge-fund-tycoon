<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bull Run Blitz - Trading Simulator Game</title>
  <meta name="description" content="The most addicting trading simulator. Build your empire from $1K to billions. No real money risk.">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üêÇ</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg: #06090f;
      --card: #0d1117;
      --card-hover: #161b22;
      --border: #21262d;
      --green: #3fb950;
      --green-bright: #56d364;
      --green-glow: rgba(63, 185, 80, 0.4);
      --red: #f85149;
      --red-glow: rgba(248, 81, 73, 0.4);
      --gold: #d29922;
      --gold-bright: #e3b341;
      --blue: #58a6ff;
      --purple: #a371f7;
      --text: #f0f6fc;
      --text-secondary: #8b949e;
      --text-dim: #484f58;
    }
    body {
      font-family: 'Space Grotesk', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      background-image: 
        radial-gradient(ellipse at top left, rgba(63, 185, 80, 0.08), transparent 40%),
        radial-gradient(ellipse at bottom right, rgba(88, 166, 255, 0.05), transparent 40%);
    }
    
    /* Header */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 20px;
      background: var(--card);
      border-bottom: 1px solid var(--border);
      height: 52px;
    }
    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .logo-icon {
      font-size: 1.6rem;
      filter: drop-shadow(0 0 8px var(--green-glow));
    }
    .logo-text {
      font-size: 1.2rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--green-bright), var(--blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .stats-bar {
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .stat {
      text-align: center;
      padding: 4px 12px;
      background: var(--card-hover);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .stat-label {
      font-size: 0.6rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .stat-value {
      font-size: 1rem;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
    }
    .stat-value.green { color: var(--green-bright); }
    .stat-value.red { color: var(--red); }
    .stat-value.gold { color: var(--gold-bright); }
    
    .streak-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 14px;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
    }
    .streak-badge.hot {
      background: linear-gradient(135deg, #ff6b35, #f7931e);
      border-color: #ff6b35;
      color: #000;
      animation: glow 1.5s ease infinite alternate;
    }
    @keyframes glow {
      from { box-shadow: 0 0 5px #ff6b35; }
      to { box-shadow: 0 0 20px #ff6b35, 0 0 30px #f7931e; }
    }
    
    /* Main Layout */
    .main {
      display: grid;
      grid-template-columns: 1fr 260px;
      gap: 12px;
      padding: 12px;
      height: calc(100vh - 52px);
      overflow: hidden;
    }
    .chart-area {
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
    }
    
    /* Chart */
    .chart-container {
      flex: 1;
      background: var(--card);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 12px;
      position: relative;
      min-height: 0;
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .ticker-group {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .ticker {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .ticker-badge {
      font-size: 0.65rem;
      padding: 2px 6px;
      background: var(--card-hover);
      border-radius: 4px;
      color: var(--text-secondary);
    }
    .price-display {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.4rem;
      font-weight: 600;
    }
    .price-change {
      font-size: 0.85rem;
      padding: 4px 10px;
      border-radius: 6px;
      font-weight: 500;
    }
    .price-change.up { background: var(--green-glow); color: var(--green-bright); }
    .price-change.down { background: var(--red-glow); color: var(--red); }
    
    .controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .control-btn {
      padding: 6px 12px;
      background: var(--card-hover);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text-secondary);
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
    }
    .control-btn:hover { background: var(--border); color: var(--text); }
    .control-btn.active { background: var(--blue); border-color: var(--blue); color: #fff; }
    
    #chartCanvas {
      width: 100%;
      height: calc(100% - 44px);
      border-radius: 8px;
    }
    
    /* Trading Panel */
    .trade-panel {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      background: var(--card);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 14px;
    }
    .trade-col h4 {
      font-size: 0.7rem;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }
    .trade-value {
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;
      font-weight: 500;
      margin-bottom: 10px;
    }
    .size-row {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }
    .size-row input {
      flex: 1;
      padding: 8px 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
    }
    .size-row input:focus { outline: none; border-color: var(--blue); }
    .size-presets {
      display: flex;
      gap: 4px;
    }
    .preset-btn {
      padding: 6px 8px;
      background: var(--card-hover);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-secondary);
      font-size: 0.7rem;
      cursor: pointer;
      font-family: inherit;
    }
    .preset-btn:hover { border-color: var(--blue); color: var(--blue); }
    
    .action-buttons {
      display: flex;
      gap: 8px;
      grid-column: span 2;
    }
    .action-btn {
      flex: 1;
      padding: 14px;
      border: none;
      border-radius: 10px;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s;
      font-family: inherit;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .action-btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none !important; }
    .action-btn.long {
      background: linear-gradient(135deg, var(--green), #2ea043);
      color: #fff;
    }
    .action-btn.long:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px var(--green-glow);
    }
    .action-btn.short {
      background: linear-gradient(135deg, var(--red), #da3633);
      color: #fff;
    }
    .action-btn.short:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px var(--red-glow);
    }
    .action-btn.close {
      background: var(--card-hover);
      border: 1px solid var(--border);
      color: var(--text);
      flex: 0.5;
    }
    
    /* Sidebar */
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow-y: auto;
      min-height: 0;
    }
    .panel {
      background: var(--card);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 14px;
    }
    .panel-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    /* Rank */
    .rank-card {
      text-align: center;
      padding: 16px;
      background: linear-gradient(135deg, var(--card-hover), var(--bg));
      border-radius: 10px;
      margin-bottom: 12px;
    }
    .rank-icon { font-size: 2.2rem; margin-bottom: 6px; }
    .rank-name {
      font-size: 1rem;
      font-weight: 700;
      background: linear-gradient(135deg, var(--gold-bright), #f0883e);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .rank-sub { font-size: 0.7rem; color: var(--text-dim); }
    .progress-track {
      height: 6px;
      background: var(--bg);
      border-radius: 3px;
      overflow: hidden;
      margin: 10px 0 6px;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--blue), var(--purple));
      border-radius: 3px;
      transition: width 0.4s ease;
    }
    .progress-label {
      font-size: 0.65rem;
      color: var(--text-dim);
      text-align: center;
    }
    
    /* Achievements */
    .achievements-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 10px;
    }
    .ach-icon {
      width: 28px;
      height: 28px;
      background: var(--bg);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      opacity: 0.25;
      transition: all 0.3s;
      cursor: help;
    }
    .ach-icon.unlocked {
      opacity: 1;
      background: linear-gradient(135deg, var(--gold), #f0883e);
      box-shadow: 0 2px 10px rgba(210, 153, 34, 0.4);
    }
    
    /* Powerups */
    .powerups-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }
    .powerup {
      padding: 10px 6px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    .powerup:hover:not(.locked):not(.cooldown) {
      border-color: var(--purple);
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(163, 113, 247, 0.2);
    }
    .powerup.locked { opacity: 0.3; cursor: not-allowed; }
    .powerup.cooldown { opacity: 0.5; cursor: not-allowed; }
    .powerup-icon { font-size: 1.3rem; margin-bottom: 4px; }
    .powerup-name { font-size: 0.6rem; font-weight: 500; color: var(--text-secondary); }
    .powerup-count { font-size: 0.55rem; color: var(--purple); margin-top: 2px; }
    
    /* Upgrades */
    .upgrade {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .upgrade:hover:not(.owned):not(.locked) { border-color: var(--gold); }
    .upgrade.owned { border-color: var(--green); background: rgba(63, 185, 80, 0.1); }
    .upgrade.locked { opacity: 0.35; cursor: not-allowed; }
    .upgrade-icon { font-size: 1.2rem; }
    .upgrade-info { flex: 1; }
    .upgrade-name { font-size: 0.8rem; font-weight: 600; }
    .upgrade-desc { font-size: 0.6rem; color: var(--text-dim); }
    .upgrade-cost { font-size: 0.75rem; font-weight: 600; color: var(--gold-bright); }
    .upgrade-cost.done { color: var(--green-bright); }
    
    /* Rewarded Ad Button */
    .ad-btn {
      width: 100%;
      padding: 12px;
      background: linear-gradient(135deg, #7c3aed, #a855f7);
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      margin-top: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s;
      font-family: inherit;
    }
    .ad-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 20px rgba(168, 85, 247, 0.4); }
    .ad-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    
    /* Notifications */
    .toast {
      position: fixed;
      top: 70px;
      right: 20px;
      padding: 14px 22px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6);
      z-index: 1000;
      animation: slideIn 0.35s cubic-bezier(0.16, 1, 0.3, 1);
      max-width: 300px;
      font-weight: 500;
    }
    .toast.success { border-color: var(--green); }
    .toast.error { border-color: var(--red); }
    .toast.achievement { 
      border-color: var(--gold); 
      background: linear-gradient(135deg, var(--card), rgba(210, 153, 34, 0.15));
    }
    @keyframes slideIn {
      from { transform: translateX(120%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    
    .flash-overlay {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 500;
      animation: flash 0.35s ease-out;
    }
    .flash-overlay.win { background: radial-gradient(circle at center, var(--green-glow), transparent 70%); }
    .flash-overlay.lose { background: radial-gradient(circle at center, var(--red-glow), transparent 70%); }
    @keyframes flash {
      0% { opacity: 0.7; }
      100% { opacity: 0; }
    }
    
    /* Tooltip */
    .chart-tooltip {
      position: absolute;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      font-family: 'JetBrains Mono', monospace;
    }
    
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }
    
    /* ========== MOBILE RESPONSIVE ========== */
    @media (max-width: 900px) {
      .main {
        grid-template-columns: 1fr;
        grid-template-rows: 1fr auto;
        overflow-y: auto;
      }
      .sidebar {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 10px;
      }
      .chart-container {
        min-height: 400px;
      }
    }
    
    @media (max-width: 600px) {
      .header {
        flex-wrap: wrap;
        height: auto;
        padding: 8px 12px;
        gap: 8px;
      }
      .stats-bar {
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        width: 100%;
      }
      .stat {
        padding: 4px 8px;
        min-width: 70px;
      }
      .stat-label { font-size: 0.5rem; }
      .stat-value { font-size: 0.8rem; }
      .logo-text { font-size: 1rem; }
      
      .main {
        padding: 8px;
        gap: 8px;
      }
      
      .chart-header {
        flex-wrap: wrap;
        gap: 8px;
      }
      .ticker { font-size: 0.9rem; }
      .price-display { font-size: 1.2rem; }
      .controls {
        flex-wrap: wrap;
        gap: 4px;
      }
      .control-btn {
        padding: 6px 10px;
        font-size: 0.75rem;
      }
      
      .trade-panel {
        grid-template-columns: 1fr;
      }
      .action-buttons {
        grid-column: span 1;
      }
      .action-btn {
        padding: 16px 10px;
        font-size: 0.9rem;
      }
      
      .sidebar {
        grid-template-columns: 1fr;
      }
      
      .powerups-grid {
        grid-template-columns: repeat(3, 1fr);
      }
      
      /* Modal mobile adjustments */
      .modal-content {
        margin: 20% auto;
        width: 90%;
        max-width: 320px;
      }
    }
    
    /* ========== RANK REQUIRED MODAL ========== */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .modal-overlay.show {
      opacity: 1;
      pointer-events: all;
    }
    .modal-content {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 28px 24px;
      max-width: 360px;
      width: 85%;
      text-align: center;
      transform: scale(0.9);
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 0 25px 50px rgba(0,0,0,0.5);
    }
    .modal-overlay.show .modal-content {
      transform: scale(1);
    }
    .modal-icon {
      font-size: 3rem;
      margin-bottom: 16px;
    }
    .modal-title {
      font-size: 1.3rem;
      font-weight: 700;
      margin-bottom: 8px;
      color: var(--text);
    }
    .modal-text {
      font-size: 0.95rem;
      color: var(--text-secondary);
      margin-bottom: 20px;
      line-height: 1.5;
    }
    .modal-requirement {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 14px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .modal-rank-icon {
      font-size: 2rem;
    }
    .modal-rank-info {
      text-align: left;
      flex: 1;
    }
    .modal-rank-name {
      font-weight: 600;
      color: var(--text);
    }
    .modal-rank-sub {
      font-size: 0.8rem;
      color: var(--text-dim);
    }
    .modal-btn {
      width: 100%;
      padding: 14px;
      background: var(--blue);
      border: none;
      border-radius: 10px;
      color: #fff;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      transition: all 0.2s;
    }
    .modal-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(88, 166, 255, 0.3);
    }
  </style>
</head>
<body>
  <!-- Rank Required Modal -->
  <div class="modal-overlay" id="rankModal">
    <div class="modal-content">
      <div class="modal-icon" id="modalIcon">üîí</div>
      <div class="modal-title" id="modalTitle">Rank Required</div>
      <div class="modal-text" id="modalText">You need to reach a higher rank to use this feature.</div>
      <div class="modal-requirement">
        <div class="modal-rank-icon" id="modalRankIcon">üìä</div>
        <div class="modal-rank-info">
          <div class="modal-rank-name" id="modalRankName">Day Trader</div>
          <div class="modal-rank-sub" id="modalRankSub">Required Rank</div>
        </div>
      </div>
      <button class="modal-btn" onclick="closeModal()">Got it</button>
    </div>
  </div>

  <header class="header">
    <div class="logo">
      <span class="logo-icon">üêÇ</span>
      <span class="logo-text">Bull Run Blitz</span>
    </div>
    <div class="stats-bar">
      <div class="stat">
        <div class="stat-label">Portfolio</div>
        <div class="stat-value gold" id="portfolio">$1,000</div>
      </div>
      <div class="stat">
        <div class="stat-label">Day P&L</div>
        <div class="stat-value green" id="dayPnl">+$0</div>
      </div>
      <div class="stat">
        <div class="stat-label">Win Rate</div>
        <div class="stat-value" id="winRate">0%</div>
      </div>
      <div class="streak-badge" id="streak">
        üî• <span id="streakNum">0</span>
      </div>
      <div class="stat">
        <div class="stat-label">AUM</div>
        <div class="stat-value" id="aum">$0</div>
      </div>
    </div>
  </header>

  <main class="main">
    <div class="chart-area">
      <div class="chart-container">
        <div class="chart-header">
          <div class="ticker-group">
            <div class="ticker">
              $BULL <span class="ticker-badge">BLITZ</span>
            </div>
            <div class="price-display" id="price">$100.00</div>
            <div class="price-change up" id="change">+0.00%</div>
          </div>
          <div class="controls">
            <button class="control-btn" data-speed="0.5">0.5√ó</button>
            <button class="control-btn active" data-speed="1">1√ó</button>
            <button class="control-btn" data-speed="2">2√ó</button>
            <button class="control-btn" data-speed="4">4√ó</button>
            <button class="control-btn" id="pauseBtn">‚è∏</button>
          </div>
        </div>
        <canvas id="chart"></canvas>
        <div class="chart-tooltip" id="tooltip" style="display:none"></div>
      </div>
      
      <div class="trade-panel">
        <div class="trade-col">
          <h4>Position</h4>
          <div class="trade-value" id="posInfo">None</div>
          <div class="size-row">
            <input type="number" id="size" value="100" min="1">
            <div class="size-presets">
              <button class="preset-btn" data-p="25">25%</button>
              <button class="preset-btn" data-p="50">50%</button>
              <button class="preset-btn" data-p="100">MAX</button>
            </div>
          </div>
        </div>
        <div class="trade-col">
          <h4>Unrealized P&L</h4>
          <div class="trade-value" id="pnl">$0.00</div>
          <h4>Entry</h4>
          <div class="trade-value" id="entry">‚Äî</div>
        </div>
        <div class="action-buttons">
          <button class="action-btn long" id="longBtn">üêÇ Long</button>
          <button class="action-btn short" id="shortBtn">üêª Short</button>
          <button class="action-btn close" id="closeBtn" disabled>Close</button>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <div class="panel-title">üèÜ Rank</div>
        <div class="rank-card">
          <div class="rank-icon" id="rankIcon">üê£</div>
          <div class="rank-name" id="rankName">Retail Trader</div>
          <div class="rank-sub" id="rankSub">Just getting started</div>
        </div>
        <div class="progress-track">
          <div class="progress-fill" id="progress" style="width:0%"></div>
        </div>
        <div class="progress-label" id="nextRank">Next: Day Trader at $5,000</div>
        <div class="achievements-row" id="achievements"></div>
      </div>
      
      <div class="panel">
        <div class="panel-title">‚ö° Power-Ups</div>
        <div class="powerups-grid" id="powerups"></div>
        <button class="ad-btn" id="adBtn">üì∫ Watch Ad ‚Üí Free Power-Up</button>
      </div>
      
      <div class="panel">
        <div class="panel-title">üõí Upgrades</div>
        <div id="upgrades"></div>
      </div>
    </div>
  </main>

  <script>
    // ========== GAME STATE ==========
    const G = {
      cash: 1000,
      dayPnl: 0,
      totalPnl: 0,
      trades: 0,
      wins: 0,
      streak: 0,
      bestStreak: 0,
      aum: 0,
      rank: 0,
      pos: null,
      candles: [],
      price: 100,
      basePrice: 100,
      speed: 1,
      paused: false,
      tick: 0,
      cw: 9,
      cg: 3,
      visible: 75,
      sound: true,
      powerups: {
        rewind: { n: 1, cd: 0 },
        slowmo: { n: 1, cd: 0 },
        insider: { n: 0, cd: 0, on: false, dur: 0 },
        shield: { n: 0, on: false },
        frenzy: { n: 0, on: false, dur: 0 }
      },
      upgrades: { monitors: false, alerts: false, news: false, quant: false, patternRec: false },
      achievements: { first: false, win: false, s3: false, s5: false, s10: false, whale: false, mm: false },
      adCooldown: 0
    };

    const ranks = [
      { name: 'Retail Trader', icon: 'üê£', sub: 'Just getting started', t: 0 },
      { name: 'Day Trader', icon: 'üìä', sub: 'Making moves', t: 5000 },
      { name: 'Swing Trader', icon: 'ü¶Ö', sub: 'Catching waves', t: 25000 },
      { name: 'Fund Manager', icon: 'üíº', sub: 'Running a fund', t: 100000 },
      { name: 'Hedge Fund', icon: 'üèõÔ∏è', sub: 'Institutional', t: 500000 },
      { name: 'Elite Trader', icon: 'üëë', sub: 'Top 1%', t: 2000000 },
      { name: 'Market Legend', icon: 'üåü', sub: 'Hall of Fame', t: 10000000 }
    ];
    const achs = [
      { id: 'first', icon: 'üéØ', name: 'First Blood', d: 'First trade' },
      { id: 'win', icon: '‚úÖ', name: 'Winner', d: 'First win' },
      { id: 's3', icon: 'üî•', name: 'Hot Hand', d: '3 streak' },
      { id: 's5', icon: 'üí•', name: 'On Fire', d: '5 streak' },
      { id: 's10', icon: '‚ö°', name: 'Unstoppable', d: '10 streak' },
      { id: 'whale', icon: 'üêã', name: 'Whale', d: '$1K single trade' },
      { id: 'mm', icon: 'üíé', name: 'Millionaire', d: 'Hit $1M' }
    ];
    const pows = [
      { id: 'rewind', icon: '‚è™', name: 'Rewind' },
      { id: 'slowmo', icon: 'üê¢', name: 'Slow-Mo' },
      { id: 'insider', icon: 'üîÆ', name: 'Insider' },
      { id: 'shield', icon: 'üõ°Ô∏è', name: 'Shield' },
      { id: 'frenzy', icon: 'üíπ', name: 'Frenzy' }
    ];
    const upgs = [
      { id: 'monitors', icon: 'üñ•Ô∏è', name: 'Dual Monitors', d: '+15 candles', p: 500, r: 0 },
      { id: 'alerts', icon: 'ü§ñ', name: 'Trade Alerts', d: 'Flash on moves', p: 2000, r: 1 },
      { id: 'news', icon: 'üì∞', name: 'News Feed', d: 'Market news', p: 5000, r: 1 },
      { id: 'quant', icon: 'üßÆ', name: 'Quant Models', d: '+10% bonus', p: 25000, r: 2 },
      { id: 'patternRec', icon: 'üîÆ', name: 'Pattern AI', d: 'Shows chart patterns', p: 15000, r: 2 }
    ];

    // ========== AUDIO ==========
    let actx;
    function beep(type) {
      if (!G.sound) return;
      if (!actx) actx = new (window.AudioContext || window.webkitAudioContext)();
      const o = actx.createOscillator(), g = actx.createGain();
      o.connect(g); g.connect(actx.destination);
      const t = actx.currentTime;
      if (type === 'buy') { o.frequency.setValueAtTime(500, t); o.frequency.exponentialRampToValueAtTime(800, t + 0.1); }
      else if (type === 'sell') { o.frequency.setValueAtTime(600, t); o.frequency.exponentialRampToValueAtTime(350, t + 0.1); }
      else if (type === 'win') { o.frequency.setValueAtTime(523, t); o.frequency.setValueAtTime(659, t + 0.1); o.frequency.setValueAtTime(784, t + 0.2); }
      else if (type === 'lose') { o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(200, t + 0.15); }
      else if (type === 'ach') { o.type = 'triangle'; o.frequency.setValueAtTime(523, t); o.frequency.setValueAtTime(784, t + 0.12); o.frequency.setValueAtTime(1047, t + 0.24); }
      g.gain.setValueAtTime(0.08, t);
      g.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      o.start(t); o.stop(t + 0.35);
    }

    // ========== CANVAS ==========
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');
    function resize() {
      const r = canvas.parentElement.getBoundingClientRect();
      canvas.width = r.width - 24;
      canvas.height = r.height - 54;
      G.visible = Math.floor(canvas.width / (G.cw + G.cg));
      if (G.upgrades.monitors) G.visible += 15;
    }
    window.addEventListener('resize', resize);
    resize();

    // ========== REALISTIC MARKET ENGINE ==========
    // Simulates real 10-second candlestick price action
    const M = {
      // Price levels
      price: 100,
      vwap: 100,
      
      // Market regime
      regime: 'balanced', // balanced, trending, ranging, volatile
      regimeDur: 0,
      
      // Microstructure
      spread: 0.02, // Bid-ask spread
      volume: 1,
      volumeTrend: 0,
      
      // Momentum & trends
      microTrend: 0,
      macroTrend: 0,
      trendStrength: 0,
      
      // Support/resistance levels (round numbers)
      levels: [],
      
      // Volatility clustering
      baseVol: 0.0008, // Base volatility per tick (10-sec chart)
      currentVol: 0.0008,
      volRegime: 'normal', // normal, high, low
      
      // Order flow
      buyPressure: 0,
      sellPressure: 0,
      
      // Time-based effects
      timeOfDay: 0,
      
      // Pattern state
      pattern: null,
      patternProgress: 0,
      
      lastClose: 100
    };

    // Market regimes with realistic characteristics
    const REGIMES = {
      balanced: { volMult: 1.0, trendDecay: 0.95, meanRev: 0.02, desc: 'Normal two-way action' },
      trending: { volMult: 1.3, trendDecay: 0.99, meanRev: 0.005, desc: 'Directional movement' },
      ranging: { volMult: 0.7, trendDecay: 0.90, meanRev: 0.05, desc: 'Stuck in a range' },
      volatile: { volMult: 2.0, trendDecay: 0.97, meanRev: 0.01, desc: 'Wild swings' },
      breakout: { volMult: 1.5, trendDecay: 0.98, meanRev: 0.01, desc: 'Breaking levels' }
    };

    // Realistic patterns for 10-second charts
    const PATTERNS = {
      none: { prob: 0.4, dur: [5, 15] },
      micro_trend: { prob: 0.15, dur: [8, 20] }, // 3-6 candles
      pullback: { prob: 0.15, dur: [3, 8] }, // Quick pullback in trend
      consolidation: { prob: 0.12, dur: [10, 25] }, // Tight range
      spike: { prob: 0.08, dur: [2, 5] }, // Sudden move
      reversal: { prob: 0.07, dur: [5, 12] }, // V-shaped
      wick_hunt: { prob: 0.03, dur: [2, 4] } // Stop hunt with quick reversal
    };

    function initLevels() {
      // Generate realistic support/resistance at round numbers
      M.levels = [];
      const base = Math.floor(M.price / 5) * 5;
      for (let i = -20; i <= 20; i++) {
        const level = base + i * 5;
        if (level > 0) {
          M.levels.push({
            price: level,
            strength: Math.random() * 0.5 + 0.5,
            touched: 0,
            broken: false
          });
        }
      }
    }
    initLevels();

    function selectPattern() {
      const r = Math.random();
      let cum = 0;
      for (const [name, cfg] of Object.entries(PATTERNS)) {
        cum += cfg.prob;
        if (r < cum) return name;
      }
      return 'none';
    }

    function updateRegime() {
      if (--M.regimeDur <= 0) {
        // Select new regime based on current conditions
        const r = Math.random();
        if (r < 0.35) M.regime = 'balanced';
        else if (r < 0.55) M.regime = 'trending';
        else if (r < 0.75) M.regime = 'ranging';
        else if (r < 0.90) M.regime = 'volatile';
        else M.regime = 'breakout';
        
        M.regimeDur = 20 + Math.floor(Math.random() * 40);
        
        // Set trend based on regime
        const cfg = REGIMES[M.regime];
        if (M.regime === 'trending' || M.regime === 'breakout') {
          M.macroTrend = (Math.random() > 0.5 ? 1 : -1) * (0.3 + Math.random() * 0.4);
          M.trendStrength = 0.6 + Math.random() * 0.4;
        } else if (M.regime === 'ranging') {
          M.macroTrend = (Math.random() - 0.5) * 0.2;
          M.trendStrength = 0.2;
        } else {
          M.macroTrend *= 0.5;
          M.trendStrength = Math.max(0.1, M.trendStrength * 0.7);
        }
        
        M.currentVol = M.baseVol * cfg.volMult;
      }
      
      // Decay trend
      const cfg = REGIMES[M.regime];
      M.macroTrend *= cfg.trendDecay;
      M.microTrend *= 0.9;
      
      // Add noise to trend
      M.macroTrend += (Math.random() - 0.5) * 0.02;
    }

    function updatePattern() {
      if (--M.patternProgress <= 0 || M.pattern === 'none') {
        M.pattern = selectPattern();
        const cfg = PATTERNS[M.pattern];
        M.patternProgress = cfg.dur[0] + Math.floor(Math.random() * (cfg.dur[1] - cfg.dur[0]));
      }
    }

    function calculateLevelEffect(price) {
      let effect = 0;
      M.levels.forEach(level => {
        const dist = Math.abs(price - level.price) / price;
        if (dist < 0.005) { // Within 0.5%
          // Price is near a level - bounce or break
          const bounceProb = level.strength * (1 - level.touched * 0.1);
          if (Math.random() < bounceProb && !level.broken) {
            // Bounce off level
            effect += (price < level.price ? 0.001 : -0.001) * level.strength;
          } else {
            // Level weakening
            level.strength *= 0.95;
            if (level.strength < 0.3) level.broken = true;
          }
          level.touched++;
        }
      });
      return effect;
    }

    function fatTailRandom() {
      // Generate fat-tailed distribution (more extreme values than normal)
      const u = Math.random();
      const v = Math.random();
      // Box-Muller with fatter tails
      const normal = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      // Mix normal with occasional extreme moves
      if (Math.random() < 0.05) {
        return normal * 3; // 5% chance of 3x move
      }
      return normal * (0.5 + Math.random() * 0.5);
    }

    function updateMarket() {
      updateRegime();
      updatePattern();
      
      // Update volume with mean reversion
      M.volumeTrend += (Math.random() - 0.5) * 0.3;
      M.volumeTrend *= 0.9;
      M.volume = Math.max(0.3, Math.min(3, 1 + M.volumeTrend + (Math.random() - 0.5) * 0.5));
      
      // Higher volume = more volatility
      const volBoost = 1 + (M.volume - 1) * 0.3;
      M.currentVol = REGIMES[M.regime].volMult * M.baseVol * volBoost;
    }

    function genCandle() {
      updateMarket();
      const o = M.price;
      let h = o, l = o, p = o;
      
      // 10-second candle: 100 ticks at 100ms each
      const ticks = 100;
      const tickVol = M.currentVol / Math.sqrt(ticks);
      
      // Pattern-specific setup
      let patternBias = 0;
      let patternVolMult = 1;
      
      switch(M.pattern) {
        case 'micro_trend':
          patternBias = (Math.random() > 0.5 ? 1 : -1) * 0.0003;
          break;
        case 'pullback':
          patternBias = -Math.sign(M.macroTrend || 1) * 0.0004;
          patternVolMult = 0.8;
          break;
        case 'consolidation':
          patternBias = 0;
          patternVolMult = 0.5;
          break;
        case 'spike':
          patternBias = (Math.random() > 0.5 ? 1 : -1) * 0.001;
          patternVolMult = 2.0;
          break;
        case 'reversal':
          patternBias = -Math.sign(M.macroTrend || 1) * 0.0005 * (M.patternProgress / 5);
          break;
        case 'wick_hunt':
          // Create long wick then reverse
          patternBias = (Math.random() > 0.5 ? 1 : -1) * 0.0015;
          break;
      }
      
      // Generate tick data
      for (let i = 0; i < ticks; i++) {
        const progress = i / ticks;
        
        // Fat-tailed random move
        let move = fatTailRandom() * tickVol * patternVolMult;
        
        // Add pattern bias
        move += patternBias;
        
        // Add micro-trend component
        M.microTrend += (Math.random() - 0.5) * 0.0001;
        M.microTrend *= 0.95;
        move += M.microTrend;
        
        // Add macro trend component
        move += M.macroTrend * 0.00005;
        
        // Mean reversion to VWAP
        const vwapDist = (p - M.vwap) / M.vwap;
        const cfg = REGIMES[M.regime];
        move -= vwapDist * cfg.meanRev * 0.01;
        
        // Support/resistance effect
        move += calculateLevelEffect(p);
        
        // Market impact (larger moves when breaking levels)
        const levelBreak = M.levels.find(l => Math.abs(p - l.price) < 0.05 && l.broken);
        if (levelBreak && Math.random() < 0.3) {
          move += Math.sign(move) * 0.0005; // Acceleration after break
        }
        
        // Update price
        p *= 1 + move;
        h = Math.max(h, p);
        l = Math.min(l, p);
        
        // Update VWAP (volume-weighted)
        M.vwap = (M.vwap * (i + 1) + p * M.volume) / (i + 1 + M.volume);
      }
      
      // Pattern completion effects
      if (M.pattern === 'wick_hunt' && M.patternProgress <= 1) {
        // Snap back after wick
        p = o + (o - h) * 0.7; // Retrace most of the wick
      }
      
      // Ensure minimum body size (avoid too many dojis)
      if (Math.abs(p - o) / o < 0.0002) {
        p = o * (1 + (Math.random() - 0.5) * 0.0005);
      }
      
      // Realistic wick extension
      const bodyRange = Math.abs(p - o);
      const totalRange = h - l;
      
      // 70% of candles should have visible wicks
      if (totalRange < bodyRange * 1.2) {
        const wickExt = bodyRange * (0.3 + Math.random() * 0.5);
        if (p > o) {
          h = Math.max(h, p + wickExt * Math.random());
          l = Math.min(l, o - wickExt * Math.random() * 0.5);
        } else {
          l = Math.min(l, p - wickExt * Math.random());
          h = Math.max(h, o + wickExt * Math.random() * 0.5);
        }
      }
      
      M.price = p;
      G.price = p;
      G.tick++;
      M.lastClose = p;
      
      // Occasionally add new levels
      if (Math.random() < 0.02) {
        const newLevel = Math.round(p / 5) * 5;
        if (!M.levels.find(l => Math.abs(l.price - newLevel) < 1)) {
          M.levels.push({
            price: newLevel,
            strength: 0.8,
            touched: 0,
            broken: false
          });
          // Remove old levels
          if (M.levels.length > 40) M.levels.shift();
        }
      }
      
      return { 
        o, 
        h: Math.max(o, p, h), 
        l: Math.min(o, p, l), 
        c: p, 
        v: M.volume * (100 + Math.random() * 50),
        t: Date.now(), 
        pattern: M.pattern,
        regime: M.regime
      };
    }

    // ========== DRAW ==========
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!G.candles.length) return;
      
      // Get visible candles
      const vis = G.candles.slice(-G.visible);
      
      // Calculate min/max for scaling
      let minP = Infinity, maxP = -Infinity;
      vis.forEach(c => { 
        minP = Math.min(minP, c.l); 
        maxP = Math.max(maxP, c.h); 
      });
      const pad = (maxP - minP) * 0.08 || 0.5; // Tighter padding for 10-sec chart
      minP -= pad; 
      maxP += pad;
      
      // Reserve space for volume at bottom
      const volHeight = G.upgrades.patternRec ? 50 : 0; // Show volume if Pattern AI unlocked
      const chartHeight = canvas.height - 28 - volHeight;
      const range = maxP - minP;
      const H = chartHeight - 14;
      const W = canvas.width - 50;

      // Draw grid lines (price)
      ctx.strokeStyle = '#21262d'; 
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = 14 + (H / 4) * i;
        ctx.beginPath(); 
        ctx.moveTo(50, y); 
        ctx.lineTo(canvas.width, y); 
        ctx.stroke();
        ctx.fillStyle = '#484f58'; 
        ctx.font = '10px JetBrains Mono'; 
        ctx.textAlign = 'right';
        ctx.fillText('$' + (maxP - (range / 4) * i).toFixed(2), 48, y + 3);
      }
      
      // Draw VWAP line if pattern AI unlocked
      if (G.upgrades.patternRec && M.vwap) {
        const vwapY = 14 + ((maxP - M.vwap) / range) * H;
        ctx.strokeStyle = 'rgba(210, 153, 34, 0.6)';
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(50, vwapY);
        ctx.lineTo(canvas.width, vwapY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // VWAP label
        ctx.fillStyle = 'rgba(210, 153, 34, 0.8)';
        ctx.font = '9px JetBrains Mono';
        ctx.textAlign = 'left';
        ctx.fillText('VWAP', 52, vwapY - 3);
      }

      // FIXED: Proper x-coordinate calculation
      const cw = G.cw; // Candle width
      const cg = G.cg; // Candle gap
      const totalCandleWidth = cw + cg;
      
      // Start from right edge and work backwards
      // Rightmost candle should be at canvas.width - margin
      const rightMargin = 20;
      const startX = canvas.width - rightMargin - cw;
      
      vis.forEach((c, i) => {
        // i=0 is rightmost (most recent), i increases going left
        const x = startX - (vis.length - 1 - i) * totalCandleWidth;
        const green = c.c >= c.o;
        
        // Calculate Y coordinates (inverted because canvas Y increases downward)
        const oY = 14 + ((maxP - c.o) / range) * H;
        const cY = 14 + ((maxP - c.c) / range) * H;
        const hY = 14 + ((maxP - c.h) / range) * H;
        const lY = 14 + ((maxP - c.l) / range) * H;
        
        // Draw wick (high to low)
        ctx.strokeStyle = green ? '#3fb950' : '#f85149'; 
        ctx.lineWidth = 1;
        ctx.beginPath(); 
        ctx.moveTo(x + cw / 2, hY); 
        ctx.lineTo(x + cw / 2, lY); 
        ctx.stroke();
        
        // Draw body (open to close)
        ctx.fillStyle = green ? '#3fb950' : '#f85149';
        const bodyTop = Math.min(oY, cY);
        const bodyHeight = Math.max(Math.abs(cY - oY), 1);
        ctx.fillRect(x, bodyTop, cw, bodyHeight);
      });
      
      // Draw current pattern indicator if player has pattern recognition upgrade
      if (M.pattern && G.upgrades.patternRec) {
        ctx.fillStyle = 'rgba(210, 153, 34, 0.9)';
        ctx.font = 'bold 11px JetBrains Mono';
        ctx.textAlign = 'left';
        ctx.fillText(`Pattern: ${M.pattern.replace('_', ' ').toUpperCase()}`, 60, 26);
        ctx.fillStyle = 'rgba(139, 148, 158, 0.8)';
        ctx.font = '9px JetBrains Mono';
        ctx.fillText(`Regime: ${M.regime} | VWAP: $${M.vwap.toFixed(2)}`, 60, 38);
      }
      
      // Draw volume bars at bottom
      const volH = 40;
      const volBaseY = canvas.height - 14 - volH;
      let maxVol = 0;
      vis.forEach(c => { if (c.v) maxVol = Math.max(maxVol, c.v); });
      
      if (maxVol > 0 && G.upgrades.patternRec) {
        // Volume background
        ctx.fillStyle = 'rgba(48, 54, 61, 0.3)';
        ctx.fillRect(50, volBaseY, canvas.width - 50, volH);
        
        vis.forEach((c, i) => {
          const x = startX - (vis.length - 1 - i) * totalCandleWidth;
          if (c.v) {
            const vh = (c.v / maxVol) * (volH - 8);
            const green = c.c >= c.o;
            ctx.fillStyle = green ? 'rgba(63, 185, 80, 0.5)' : 'rgba(248, 81, 73, 0.5)';
            ctx.fillRect(x, volBaseY + volH - vh, cw, vh);
          }
        });
        
        // Volume label
        ctx.fillStyle = '#8b949e';
        ctx.font = '9px JetBrains Mono';
        ctx.textAlign = 'left';
        ctx.fillText('VOL', 52, volBaseY + 12);
      }

      if (G.pos) {
        const eY = 14 + ((maxP - G.pos.entry) / range) * H;
        ctx.strokeStyle = G.pos.side === 'long' ? '#3fb950' : '#f85149';
        ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(50, eY); ctx.lineTo(canvas.width, eY); ctx.stroke(); ctx.setLineDash([]);
      }

      if (G.upgrades.alerts && G.candles.length >= 2) {
        const last = G.candles.at(-1), prev = G.candles.at(-2);
        if (Math.abs((last.c - prev.c) / prev.c) > 0.012) {
          ctx.fillStyle = last.c > prev.c ? 'rgba(63,185,80,0.08)' : 'rgba(248,81,73,0.08)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
    }

    // ========== TRADING ==========
    function openPos(side) {
      if (G.pos) return;
      const sz = parseInt(document.getElementById('size').value);
      if (sz > G.cash || sz <= 0) { toast('Insufficient funds!', 'error'); return; }
      G.pos = { side, size: sz, entry: G.price };
      beep(side === 'long' ? 'buy' : 'sell');
      if (!G.achievements.first) unlock('first');
      updateUI();
    }

    function closePos() {
      if (!G.pos) return;
      let pnl = calcPnl();
      if (G.powerups.frenzy.on && pnl > 0) pnl *= 2;
      if (G.upgrades.quant && pnl > 0) pnl *= 1.1;
      if (pnl < 0 && G.powerups.shield.on) {
        G.powerups.shield.on = false;
        toast('üõ°Ô∏è Shield blocked!', 'success');
        G.pos = null; updateUI(); return;
      }
      G.cash += pnl; G.dayPnl += pnl; G.totalPnl += pnl; G.trades++;
      if (pnl > 0) {
        G.wins++; G.streak++;
        if (G.streak > G.bestStreak) G.bestStreak = G.streak;
        beep('win'); flash('win');
        if (!G.achievements.win) unlock('win');
        if (G.streak >= 3 && !G.achievements.s3) unlock('s3');
        if (G.streak >= 5 && !G.achievements.s5) unlock('s5');
        if (G.streak >= 10 && !G.achievements.s10) unlock('s10');
        if (pnl >= 1000 && !G.achievements.whale) unlock('whale');
      } else { G.streak = 0; beep('lose'); flash('lose'); }
      toast(`${pnl >= 0 ? '‚úÖ' : '‚ùå'} ${pnl >= 0 ? '+' : ''}$${pnl.toFixed(0)}`, pnl >= 0 ? 'success' : 'error');
      G.pos = null;
      checkRank(); save(); updateUI();
    }

    function calcPnl() {
      if (!G.pos) return 0;
      const d = G.price - G.pos.entry;
      return ((G.pos.side === 'long' ? d : -d) / G.pos.entry) * G.pos.size;
    }

    // ========== POWERUPS ==========
    function usePow(id) {
      const p = G.powerups[id];
      if (p.n <= 0 || p.cd > 0) return;
      switch (id) {
        case 'rewind': if (G.candles.length > 10) { G.candles = G.candles.slice(0, -10); G.price = G.candles.at(-1).c; toast('‚è™ Rewound!', 'success'); } break;
        case 'slowmo': G.speed = 0.5; updSpeed(); setTimeout(() => { G.speed = 1; updSpeed(); }, 30000); toast('üê¢ Slow-Mo!', 'success'); break;
        case 'insider': p.on = true; p.dur = 25; toast('üîÆ Insider!', 'success'); break;
        case 'shield': p.on = true; toast('üõ°Ô∏è Shield ready!', 'success'); break;
        case 'frenzy': p.on = true; p.dur = 30; toast('üíπ FRENZY!', 'success'); break;
      }
      p.n--; p.cd = 45; updateUI();
    }

    function buyUpg(id) {
      const u = upgs.find(x => x.id === id);
      if (!u || G.upgrades[id] || G.cash < u.p || G.rank < u.r) return;
      G.cash -= u.p; G.upgrades[id] = true;
      if (id === 'monitors') G.visible += 15;
      beep('ach'); toast(`üõí ${u.name}!`, 'success'); save(); updateUI();
    }

    // ========== REWARDED AD ==========
    function watchAd() {
      if (G.adCooldown > 0) return;
      // Simulate ad (in production, integrate real ad SDK)
      toast('üì∫ Watching ad...', 'info');
      setTimeout(() => {
        const options = ['rewind', 'slowmo', 'shield'];
        const choice = options[Math.floor(Math.random() * options.length)];
        G.powerups[choice].n++;
        toast(`üéÅ Got ${pows.find(p => p.id === choice).icon}!`, 'success');
        G.adCooldown = 180; // 3 min cooldown
        updateUI();
      }, 2000);
    }

    // ========== PROGRESSION ==========
    function checkRank() {
      const tot = G.cash + G.aum;
      for (let i = ranks.length - 1; i >= 0; i--) {
        if (tot >= ranks[i].t && G.rank < i) {
          G.rank = i;
          beep('ach');
          toast(`üèÜ ${ranks[i].name}!`, 'achievement');
          if (i === 1) G.powerups.slowmo.n++;
          if (i === 2) G.powerups.insider.n++;
          if (i === 3) G.powerups.shield.n++;
          if (i === 4) G.powerups.frenzy.n++;
          break;
        }
      }
      if (tot >= 1000000 && !G.achievements.mm) unlock('mm');
      if (G.rank >= 3 && Math.random() < 0.06) {
        const amt = [10000, 25000, 50000, 100000][Math.floor(Math.random() * 4)] * (1 + G.rank * 0.5);
        G.aum += amt;
        toast(`üí∞ Investor +$${(amt / 1000).toFixed(0)}K`, 'success');
      }
    }

    function unlock(id) {
      if (G.achievements[id]) return;
      G.achievements[id] = true;
      const a = achs.find(x => x.id === id);
      beep('ach'); toast(`üèÜ ${a.icon} ${a.name}!`, 'achievement'); save(); updateUI();
    }

    // ========== UI ==========
    function updateUI() {
      document.getElementById('portfolio').textContent = '$' + G.cash.toLocaleString(undefined, { maximumFractionDigits: 0 });
      const dp = document.getElementById('dayPnl');
      dp.textContent = (G.dayPnl >= 0 ? '+' : '') + '$' + G.dayPnl.toFixed(0);
      dp.className = 'stat-value ' + (G.dayPnl >= 0 ? 'green' : 'red');
      document.getElementById('winRate').textContent = G.trades ? Math.round(G.wins / G.trades * 100) + '%' : '0%';
      document.getElementById('aum').textContent = '$' + (G.aum / 1000).toFixed(0) + 'K';
      document.getElementById('streakNum').textContent = G.streak;
      document.getElementById('streak').className = 'streak-badge' + (G.streak >= 3 ? ' hot' : '');

      document.getElementById('price').textContent = '$' + G.price.toFixed(2);
      const chg = ((G.price - G.basePrice) / G.basePrice) * 100;
      const ce = document.getElementById('change');
      ce.textContent = (chg >= 0 ? '+' : '') + chg.toFixed(2) + '%';
      ce.className = 'price-change ' + (chg >= 0 ? 'up' : 'down');

      if (G.pos) {
        document.getElementById('posInfo').textContent = G.pos.side.toUpperCase() + ' ' + G.pos.size;
        document.getElementById('entry').textContent = '$' + G.pos.entry.toFixed(2);
        const pnl = calcPnl();
        const pe = document.getElementById('pnl');
        pe.textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
        pe.style.color = pnl >= 0 ? 'var(--green-bright)' : 'var(--red)';
        document.getElementById('longBtn').disabled = true;
        document.getElementById('shortBtn').disabled = true;
        document.getElementById('closeBtn').disabled = false;
      } else {
        document.getElementById('posInfo').textContent = 'None';
        document.getElementById('entry').textContent = '‚Äî';
        document.getElementById('pnl').textContent = '$0.00';
        document.getElementById('pnl').style.color = '';
        document.getElementById('longBtn').disabled = false;
        document.getElementById('shortBtn').disabled = false;
        document.getElementById('closeBtn').disabled = true;
      }

      const r = ranks[G.rank];
      document.getElementById('rankIcon').textContent = r.icon;
      document.getElementById('rankName').textContent = r.name;
      document.getElementById('rankSub').textContent = r.sub;
      const nr = ranks[G.rank + 1];
      if (nr) {
        const prog = ((G.cash + G.aum) - r.t) / (nr.t - r.t) * 100;
        document.getElementById('progress').style.width = Math.min(100, Math.max(0, prog)) + '%';
        document.getElementById('nextRank').textContent = `Next: ${nr.name} at $${nr.t.toLocaleString()}`;
      } else {
        document.getElementById('progress').style.width = '100%';
        document.getElementById('nextRank').textContent = 'Max Rank!';
      }

      const achEl = document.getElementById('achievements');
      achEl.innerHTML = '';
      achs.forEach(a => {
        const d = document.createElement('div');
        d.className = 'ach-icon' + (G.achievements[a.id] ? ' unlocked' : '');
        d.textContent = a.icon;
        d.title = a.name + ': ' + a.d;
        achEl.appendChild(d);
      });

      const powEl = document.getElementById('powerups');
      powEl.innerHTML = '';
      pows.forEach(pw => {
        const p = G.powerups[pw.id];
        const d = document.createElement('div');
        const locked = p.n <= 0 || p.cd > 0;
        d.className = 'powerup' + (p.n <= 0 ? ' locked' : '') + (p.cd > 0 ? ' cooldown' : '');
        d.innerHTML = `<div class="powerup-icon">${pw.icon}</div><div class="powerup-name">${pw.name}</div><div class="powerup-count">${p.cd > 0 ? p.cd + 's' : 'x' + p.n}</div>`;
        d.onclick = () => {
          if (p.n <= 0) {
            showModal('üîã', 'Out of Power-Ups!', 'Watch an ad to get more power-ups, or keep trading to earn them as rewards.', {name: 'Free Power-Up', sub: 'Watch ad to recharge', icon: 'üì∫'});
          } else if (p.cd > 0) {
            showModal('‚è≥', 'On Cooldown', `This power-up is recharging. ${p.cd} seconds remaining.`, {name: 'Cooldown Active', sub: `${p.cd}s left`, icon: '‚è∞'});
          } else {
            usePow(pw.id);
          }
        };
        powEl.appendChild(d);
      });

      document.getElementById('adBtn').disabled = G.adCooldown > 0;
      document.getElementById('adBtn').textContent = G.adCooldown > 0 ? `‚è≥ ${G.adCooldown}s` : 'üì∫ Watch Ad ‚Üí Free Power-Up';

      const upgEl = document.getElementById('upgrades');
      upgEl.innerHTML = '';
      upgs.forEach(u => {
        const owned = G.upgrades[u.id], locked = G.rank < u.r;
        const d = document.createElement('div');
        d.className = 'upgrade' + (owned ? ' owned' : '') + (locked ? ' locked' : '');
        d.innerHTML = `<div class="upgrade-icon">${u.icon}</div><div class="upgrade-info"><div class="upgrade-name">${u.name}</div><div class="upgrade-desc">${locked ? 'Unlock at ' + ranks[u.r].name : u.d}</div></div><div class="upgrade-cost ${owned ? 'done' : ''}">${owned ? '‚úì' : '$' + u.p.toLocaleString()}</div>`;
        d.onclick = () => {
          if (owned) {
            showModal('‚úì', 'Already Owned!', `You already have ${u.name}. Keep trading to unlock more upgrades!`, {name: 'Owned', sub: 'Upgrade complete', icon: '‚úÖ'});
          } else if (locked) {
            const reqRank = ranks[u.r];
            showModal('üîí', 'Rank Required!', `You need to reach ${reqRank.name} to unlock this upgrade. Keep trading to rank up!`, {name: reqRank.name, sub: `Required (you're ${ranks[G.rank].name})`, icon: reqRank.icon});
          } else if (G.cash < u.p) {
            showModal('üí∞', 'Not Enough Cash!', `You need $${u.p.toLocaleString()} to buy ${u.name}. Win more trades!`, {name: 'Insufficient Funds', sub: `Need $${(u.p - G.cash).toLocaleString()} more`, icon: 'üí∏'});
          } else {
            buyUpg(u.id);
          }
        };
        upgEl.appendChild(d);
      });
    }

    // ========== MODAL ==========
    function showModal(icon, title, text, requirement) {
      document.getElementById('modalIcon').textContent = icon;
      document.getElementById('modalTitle').textContent = title;
      document.getElementById('modalText').textContent = text;
      if (requirement) {
        document.getElementById('modalRankIcon').textContent = requirement.icon;
        document.getElementById('modalRankName').textContent = requirement.name;
        document.getElementById('modalRankSub').textContent = requirement.sub;
      }
      document.getElementById('rankModal').classList.add('show');
    }
    
    function closeModal() {
      document.getElementById('rankModal').classList.remove('show');
    }
    
    // Close modal on overlay click
    document.getElementById('rankModal').onclick = (e) => {
      if (e.target.id === 'rankModal') closeModal();
    };
    
    function toast(msg, type = 'info') {
      const d = document.createElement('div');
      d.className = 'toast ' + type;
      d.textContent = msg;
      document.body.appendChild(d);
      setTimeout(() => d.remove(), 2500);
    }

    function flash(type) {
      const d = document.createElement('div');
      d.className = 'flash-overlay ' + type;
      document.body.appendChild(d);
      setTimeout(() => d.remove(), 350);
    }

    function updSpeed() {
      document.querySelectorAll('.control-btn[data-speed]').forEach(b => {
        b.classList.toggle('active', parseFloat(b.dataset.speed) === G.speed);
      });
    }

    // ========== SAVE/LOAD ==========
    function save() {
      localStorage.setItem('bullrunblitz', JSON.stringify({
        cash: G.cash, totalPnl: G.totalPnl, trades: G.trades, wins: G.wins,
        bestStreak: G.bestStreak, aum: G.aum, rank: G.rank,
        powerups: G.powerups, upgrades: G.upgrades, achievements: G.achievements
      }));
    }

    function load() {
      const s = localStorage.getItem('bullrunblitz');
      if (s) {
        const d = JSON.parse(s);
        Object.assign(G, d);
        if (G.upgrades.monitors) G.visible += 15;
      }
    }

    // ========== EVENTS ==========
    document.getElementById('longBtn').onclick = () => openPos('long');
    document.getElementById('shortBtn').onclick = () => openPos('short');
    document.getElementById('closeBtn').onclick = closePos;
    document.getElementById('adBtn').onclick = watchAd;

    document.querySelectorAll('.control-btn[data-speed]').forEach(b => {
      b.onclick = () => { G.speed = parseFloat(b.dataset.speed); updSpeed(); };
    });
    document.getElementById('pauseBtn').onclick = () => {
      G.paused = !G.paused;
      document.getElementById('pauseBtn').textContent = G.paused ? '‚ñ∂' : '‚è∏';
    };
    document.querySelectorAll('.preset-btn').forEach(b => {
      b.onclick = () => document.getElementById('size').value = Math.floor(G.cash * parseInt(b.dataset.p) / 100);
    });

    document.addEventListener('keydown', e => {
      if (e.target.tagName === 'INPUT') return;
      if (e.key.toLowerCase() === 'b') openPos('long');
      if (e.key.toLowerCase() === 's') openPos('short');
      if (e.key.toLowerCase() === 'c' || e.key.toLowerCase() === 'x') closePos();
      if (e.key === ' ') { e.preventDefault(); G.paused = !G.paused; document.getElementById('pauseBtn').textContent = G.paused ? '‚ñ∂' : '‚è∏'; }
    });

    // ========== GAME LOOP ==========
    let lt = 0, acc = 0;
    const tick = 380;

    function loop(ts) {
      if (!lt) lt = ts;
      const dt = ts - lt; lt = ts;
      if (!G.paused) {
        acc += dt * G.speed;
        while (acc >= tick) {
          G.candles.push(genCandle());
          if (G.candles.length > 500) G.candles.shift();
          Object.values(G.powerups).forEach(p => { if (p.cd > 0) p.cd--; });
          if (G.powerups.insider.on && --G.powerups.insider.dur <= 0) G.powerups.insider.on = false;
          if (G.powerups.frenzy.on && --G.powerups.frenzy.dur <= 0) G.powerups.frenzy.on = false;
          if (G.adCooldown > 0) G.adCooldown--;
          acc -= tick;
        }
      }
      draw(); updateUI();
      requestAnimationFrame(loop);
    }

    // ========== INIT ==========
    load();
    for (let i = 0; i < 45; i++) G.candles.push(genCandle());
    updateUI();
    requestAnimationFrame(loop);
    toast('üêÇ B=Long, S=Short, C=Close, Space=Pause', 'info');
  </script>
</body>
</html>
